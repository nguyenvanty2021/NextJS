import Head from "next/head";
import Image from "next/image";
import styles from "../styles/Home.module.css";
import fs from "fs/promises";
import { GetStaticProps, GetStaticPaths, GetStaticPropsContext } from "next";
import Link from "next/link";
import path from "path";
// Trường hợp: static html generation (không dùng getStaticProps, getStaticPaths, getServerSideProps trong component)
// -> thì khi npm run build or yarn build sau đó start thì nó sẽ tự động chuyển trang của mình thành file .html, khi user request thì nó đã tạo sẵn file .html, chỉ hiển thị ra mà thôi
// Trường hợp: static html + json data (dùng getStaticProps)
// Trường hợp: static html + json data + dynamic routes (dùng getStaticProps + getStaticPaths)
// Chỉ sử dụng getStaticProps + getStaticPath (2 thằng này là SSG) hoặc getServerSideProps () -> không dùng chung
// có staticProps và staticPath thì không có serverSideProp và ngược lại.
// chỉ sử dụng được 3 hàm này trong page (những component nằm trong folder pages), còn những component
// chia nhỏ nằm ngoài folder pages thì k dùng dc, chính vì vậy người ta thường sử dụng trong page rồi
// truyền data vào các component con,
// 3 hàm trên ở server-side (chỉ chạy ở phía server, client có console.log cũng không thấy) và chỉ chạy lúc build-time (khi npm run build or yarn build)
// trong môi trường dev thì chỉ cần gủi request thì nó luôn luôn chạy 3 hàm này
export default function Home({ products }) {
  console.log(props);
  // const { products } = props;
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="title" content="" />
        <meta property="fb:app_id" content="" />
        <meta property="twitter:url" content="" />
        <meta property="og:type" content="" />
        <meta property="og:site_name" content="" />
        <meta property="og:locale" content="" />
        <meta property="og:title" content="" />
        <meta property="og:description" content="" />
        <meta property="og:image" content="" />
        <meta property="og:image:secure" content="" />
        <meta name="og:url" content="" />
      </Head>

      <main className={styles.main}>
        {products &&
          products.length > 0 &&
          products.map((values, index) => {
            return (
              <div key={index}>
                <div>{values.id}</div>
                {/* khi redirect (chuyển trang) trong nextjs nó là: client site routing, nó không có làm full page reload (reload lại toàn bộ trang giống thẻ a), nó chỉ get file js về rồi nó chỉ chuyển đổi qua page nó mong muốn */}
                <Link href={`/products/${values.id}`}>
                  {/* bên trong link của nextjs phải có thêm thẻ a (tốt cho SEO)  */}
                  <a>{values.title}</a>
                </Link>
              </div>
            );
          })}
      </main>

      <footer className={styles.footer}>
        <a
          href="https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          Powered by{" "}
          <span className={styles.logo}>
            <Image src="/vercel.svg" alt="Vercel Logo" width={72} height={16} />
          </span>
        </a>
      </footer>
    </div>
  );
}

export async function getStaticProps() {
  // nếu chỗ này mình truyền vào 3 obj tương ứng với 3 id là: "1", "2", "3" thì thằng
  // getStaticProps sẽ chạy hay nói cách khác là được gọi 3 lần nhưng thằng getStaticPaths
  // này chỉ chạy hay được gọi 1 lần mà thôi. Tuỳ vào bao nhiêu obj thì getStaticProps sẽ được gọi và chạy bấy nhiêu lần
  // và sau khi npm run build or yarn build thì nó sẽ tạo ra 4 file .html và .json tương ứng với 3 id (3 obj)
  const filePath = path.join(process.cwd(), "dummy", "data.json");
  const jsonData = await fs.readFile(filePath);
  const data = JSON.parse(jsonData);
  // nếu data không tồn tại thì đẩy qua page /no-data
  if (!data) {
    return {
      redirect: {
        destination: "/no-data",
      },
    };
  }
  // nếu data tồn tại mà rỗng thì đẩy sang 404
  if (data && data.products && data.products.length === 0) {
    return { notFound: true }; // data rỗng thì đẩy nó sang page 404.
  }

  // cách 1: filesystem
  return {
    props: {
      products: data.products,
    },
    revalidate: 10, // mỗi 10s sẽ call api hay đọc filesystem 1 lần
  };
  // trường hợp array nhiều thuộc tính quá mà client chỉ cần vài thuộc tính để render thôi,
  // thì mình sẽ dùng hàm map để tạo ra 1 mảng mới
  // return {
  //   props: {
  //     object: data.products.map((x) => ({id: x.id, title: x.title})),
  //   },
  // }
  // cách 1.2: filesystem
  // const booksDir = path.join(process.cwd(), "books");
  // const bookFileNames = fs.readdirSync(booksDir);
  // const booksData = bookFileNames.map((bookFileName) => {
  //   const fullBookPath = path.join(booksDir, bookFileName);
  //   const bookContent = fs.readFileSync(fullBookPath, "utf8");
  //   return {
  //     bookName: bookFileName.replace(/\.txt$/, ""),
  //     bookContent,
  //   };
  // });
  // call api
  // cách 2
  // return {
  //   props: {
  //     products: [{ id: "1", title: "title 1" }]
  //   },
  // };

  // cách 3: call api
  // const res = await fetch("https://...");
  // const data = await res.json();
  // return {
  //   props: {
  //     products: data
  //   },
  // };
}
